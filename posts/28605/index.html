<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;datura35422.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12,&quot;onmobile&quot;:false},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script>
<meta name="description" content="Vue官网：https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;installation.html Vue-Cli 官网：https:&#x2F;&#x2F;cli.vuejs.org&#x2F;zh&#x2F;guide&#x2F; 当前文档为2.x版本 理论常见概念">
<meta property="og:type" content="article">
<meta property="og:title" content="vue系列-vue入门">
<meta property="og:url" content="https://datura35422.github.io/posts/28605/index.html">
<meta property="og:site_name" content="Wang Wei&#39;s Blog">
<meta property="og:description" content="Vue官网：https:&#x2F;&#x2F;cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;installation.html Vue-Cli 官网：https:&#x2F;&#x2F;cli.vuejs.org&#x2F;zh&#x2F;guide&#x2F; 当前文档为2.x版本 理论常见概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://datura35422.github.io/posts/28605/vue%E7%89%B9%E7%82%B9.jpg">
<meta property="og:image" content="https://datura35422.github.io/posts/28605/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="https://datura35422.github.io/posts/28605/lifecycle.png">
<meta property="og:image" content="https://datura35422.github.io/posts/28605/transition.jpg">
<meta property="og:image" content="https://datura35422.github.io/posts/28605/%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0.png">
<meta property="article:published_time" content="2019-03-19T02:17:45.000Z">
<meta property="article:modified_time" content="2025-03-23T18:16:48.088Z">
<meta property="article:author" content="Wang Wei">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://datura35422.github.io/posts/28605/vue%E7%89%B9%E7%82%B9.jpg">


<link rel="canonical" href="https://datura35422.github.io/posts/28605/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;datura35422.github.io&#x2F;posts&#x2F;28605&#x2F;&quot;,&quot;path&quot;:&quot;posts&#x2F;28605&#x2F;&quot;,&quot;title&quot;:&quot;vue系列-vue入门&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>vue系列-vue入门 | Wang Wei's Blog</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wang Wei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fas fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fas fa-calendar fa-fw"></i>日程表</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">常见概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.</span> <span class="nav-text">vue是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%88%E6%9C%AC"><span class="nav-number">1.2.1.</span> <span class="nav-text">版本</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Runtime-Compiler"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Runtime + Compiler</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Runtime-Only"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">Runtime Only</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.3.</span> <span class="nav-text">响应式系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">检测变化的注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">对于对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">对于数组</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">异步更新队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">如何进行的依赖收集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">1.4.</span> <span class="nav-text">生命周期钩子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">子组件和父组件的生命周期调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%84%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E8%BF%98%E6%9C%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">除了常规的组件生命周期，还有</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">服务端的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%EF%BC%88Virtual-DOM%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">虚拟DOM（Virtual DOM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="nav-number">1.6.</span> <span class="nav-text">组件化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Diff%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">Diff算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">1.8.</span> <span class="nav-text">编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#codegen"><span class="nav-number">1.8.1.</span> <span class="nav-text">codegen</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.</span> <span class="nav-text">实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="nav-number">2.2.</span> <span class="nav-text">事件触发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="nav-number">2.2.1.</span> <span class="nav-text">事件穿透解决方案：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Event%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">Event事件</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-v-model"><span class="nav-number">2.3.</span> <span class="nav-text">双向数据绑定 v-model</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="nav-number">2.3.1.</span> <span class="nav-text">修饰符：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">2.3.2.</span> <span class="nav-text">应用场景：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">2.3.3.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="nav-number">2.4.1.</span> <span class="nav-text">组件注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="nav-number">2.4.2.</span> <span class="nav-text">异步组件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#webpack-code-splitting"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">webpack + code splitting</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#import%E5%BC%82%E6%AD%A5%E5%AF%BC%E5%85%A5"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">import异步导入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6-%E2%80%93-%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E7%8A%B6%E6%80%81"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">高级异步组件 – 组件加载状态</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC"><span class="nav-number">2.4.3.</span> <span class="nav-text">组件间传值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8v-bind-prop%E4%BC%A0%E5%80%BC"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">使用v-bind prop传值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9C%81%E7%95%A5v-bind-prop%E4%BC%A0%E5%80%BC"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">省略v-bind prop传值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#nextTick"><span class="nav-number">2.5.1.</span> <span class="nav-text">nextTick</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E6%97%A0%E6%B3%95%E6%A3%80%E6%B5%8B%E5%88%B0%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.5.2.</span> <span class="nav-text">数据改变无法检测到的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#computed%E5%92%8Cwatch"><span class="nav-number">2.5.3.</span> <span class="nav-text">computed和watch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#set%E4%BD%BF%E7%94%A8"><span class="nav-number">2.5.4.</span> <span class="nav-text">$set使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E6%A7%BD-v-slot"><span class="nav-number">2.6.</span> <span class="nav-text">插槽 v-slot</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%8F%92%E6%A7%BD"><span class="nav-number">2.6.1.</span> <span class="nav-text">普通插槽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="nav-number">2.6.2.</span> <span class="nav-text">具名插槽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="nav-number">2.6.3.</span> <span class="nav-text">作用域插槽</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#keep-alive"><span class="nav-number">2.7.</span> <span class="nav-text">keep-alive</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="nav-number">2.8.</span> <span class="nav-text">过渡动画</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#transition"><span class="nav-number">2.8.1.</span> <span class="nav-text">transition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#transition-group"><span class="nav-number">2.8.2.</span> <span class="nav-text">transition-group</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#v-if-%E5%92%8C-v-show-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">v-if 和 v-show 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95-v-for-%E4%B8%AD%E8%A6%81%E7%94%A8key"><span class="nav-number">3.2.</span> <span class="nav-text">为何 v-for 中要用key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0Vue%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E6%9C%89%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">描述Vue组件生命周期（有父子组件的情况）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="nav-number">3.4.</span> <span class="nav-text">父子组件通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF"><span class="nav-number">3.5.</span> <span class="nav-text">兄弟组件通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.6.</span> <span class="nav-text">描述组件渲染和更新的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9Av-model%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.7.</span> <span class="nav-text">双向数据绑定v-model的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E8%A6%81%E4%BD%BF%E7%94%A8function%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.8.</span> <span class="nav-text">为什么Vue组件中的data要使用function的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">3.9.</span> <span class="nav-text">为什么要使用计算属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watch%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7"><span class="nav-number">3.10.</span> <span class="nav-text">watch监听属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%89%E9%A1%B9%E5%92%8C%E6%B7%B7%E5%85%A5%E7%9A%84%E9%80%89%E9%A1%B9%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%88%E5%B9%B6%E7%9A%84"><span class="nav-number">3.11.</span> <span class="nav-text">组件的选项和混入的选项是怎么合并的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.12.</span> <span class="nav-text">强制刷新组件的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E7%BB%84%E4%BB%B6"><span class="nav-number">3.13.</span> <span class="nav-text">销毁组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#router"><span class="nav-number">4.1.</span> <span class="nav-text">router</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vue%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">vue实例方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%A3%80"><span class="nav-number">5.</span> <span class="nav-text">自检</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">5.1.</span> <span class="nav-text">面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E9%98%85%E8%AF%BB"><span class="nav-number">5.2.</span> <span class="nav-text">更多阅读</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Wei"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Wang Wei</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">148</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Datura35422" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Datura35422" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangwei35422@163.com" title="E-Mail → mailto:wangwei35422@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Datura35422" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://datura35422.github.io/posts/28605/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Wang Wei">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wang Wei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          vue系列-vue入门
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-19 10:17:45" itemprop="dateCreated datePublished" datetime="2019-03-19T10:17:45+08:00">2019-03-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-03-24 02:16:48" itemprop="dateModified" datetime="2025-03-24T02:16:48+08:00">2025-03-24</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Vue官网：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/installation.html">https://cn.vuejs.org/v2/guide/installation.html</a></p>
<p>Vue-Cli 官网：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/">https://cli.vuejs.org/zh/guide/</a></p>
<p>当前文档为<strong>2.x</strong>版本</p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h4><p><strong>双向绑定</strong>：在表单控件或者组件上使用 v-model 创建双向绑定。数据修改视图会进行修改，视图修改数据也会跟着修改。即vue实例中的data与其渲染的DOM元素的内容保持一致，无论谁被改变，另一方会相应的更新为相同的数据。这是通过设置属性访问器实现的。</p>
<blockquote>
<p>双向绑定 = 单向绑定 + UI事件监听</p>
</blockquote>
<h4 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/index.html">vue是什么</a></h4><p>Vue 是一套用于构建用户界面的<strong>渐进式框架</strong>。</p>
<p>与其它大型框架不同的是，Vue 被设计为可以<strong>自底向上逐层应用</strong>。</p>
<p>Vue 的核心库<strong>只关注视图层</strong>，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>另一方面，当与<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/51907207">Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？</a></p>
<p>框架做分层设计，每层都可选，不同层可以灵活接入其他方案。</p>
</blockquote>
<p>Vue.js 一个核心思想是<strong>数据驱动</strong>。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。</p>
<blockquote>
<p>没有完全遵循 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM">MVVM 模型</a>，但是核心思想相同。<a href="https://datura35422.github.io/posts/17715/">MVVM与其他架构模型有什么不同</a></p>
</blockquote>
<p><img src="/posts/28605/vue%E7%89%B9%E7%82%B9.jpg" alt="vue特点"></p>
<h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><h6 id="Runtime-Compiler"><a href="#Runtime-Compiler" class="headerlink" title="Runtime + Compiler"></a>Runtime + Compiler</h6><p>包含编译代码的，可以把编译过程放在运行时做。引用的 <code>vue</code> 版本文件<code>vue.js</code></p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 需要编译器</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;div>&#123;&#123; hi &#125;&#125;&lt;/div>'</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译器会将 <code>template</code> 进行<code>parse AST -&gt; optimiz -&gt; codegen</code> 后生成使用 <code>with(this)&#123;...&#125;</code> 包裹的函数，然后在运行的时候进行使用。</p>
<h6 id="Runtime-Only"><a href="#Runtime-Only" class="headerlink" title="Runtime Only"></a>Runtime Only</h6><p>推荐使用。不包含编译代码的，需要借助 webpack 的 <code>vue-loader</code> 事先把模板编译成 <code>render</code>函数。引用的 <code>vue</code> 版本文件<code>vue.runtime.js</code></p>
<blockquote>
<p>当使用 <code>vue-loader</code> 的时候，<code>*.vue</code> 文件内部的模板会在构建时预编译成 JavaScript。</p>
</blockquote>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 不需要编译器</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hi<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">响应式系统</a></h4><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的。</p>
<p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters">getter/setter</a>。</p>
<blockquote>
<p>在 setter 中设置监听，在 getter 中响应监听事件</p>
</blockquote>
<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖（进行依赖收集）。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<blockquote>
<p><code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
</blockquote>
<p><img src="/posts/28605/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.png" alt="响应式原理"></p>
<h5 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h5><p>由于 js 的限制，vue不能检测数组和对象的变化。</p>
<p>由于 Vue 不允许动态添加根级响应式 property，所以你<strong>必须在初始化实例前声明所有根级响应式 property</strong>，哪怕只是一个空值。</p>
<h6 id="对于对象"><a href="#对于对象" class="headerlink" title="对于对象"></a>对于对象</h6><p><strong>Vue 无法检测 property 的添加或移除</strong>。由于 Vue 会在初始化时对对象进行 <code>getter / setter</code> 的转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property。</p>
<blockquote>
<p>还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名</p>
</blockquote>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span><span class="token punctuation">&#123;</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">// `vm.a` 是响应式的</span>

vm<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token comment">// `vm.b` 是非响应式的</span>

<span class="token comment">// 添加响应式属性</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>someObject<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">// 或</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObject<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有时需要为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>someObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>someObject<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h6 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h6><p>Vue 不能检测一下的数组变动：</p>
<ol>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>使用 Vue.set 的方式触发数组的响应式状态更新。</p>
<p>或者使用 push、pop、shift、unshift、splice、sort、reverse进行操作原数组，Vue 实现了这些方法的重写。</p>
 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> def <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'../util/index'</span>

<span class="token comment">// 重写原型链上修改数组的方法 利用原型链继承的方式重新设置数组类型</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>

<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// cache original method</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// notify change</span>
    <span class="token comment">// 修改数组的方法绑定了响应式 进行修改数组api操作就会通知数据修改</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h5><p>Vue 在更新 DOM 时是<strong>异步</strong>执行的。</p>
<p>只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p>
<p>然后，在下一个的事件循环“tick”中（微任务），Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>
<p>为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。</p>
<h5 id="如何进行的依赖收集"><a href="#如何进行的依赖收集" class="headerlink" title="如何进行的依赖收集"></a>如何进行的依赖收集</h5><p>时机：<strong>在初始化数据（props / data）的时候就进行依赖收集</strong>。</p>
<p>data初始化时做了是对定义 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上；同时调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式，可以通过 <code>vm._data.xxx</code> 访问到定义 <code>data</code> 返回函数中对应的属性。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">initData</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">let</span> data <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data
  data <span class="token operator">=</span> vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'data functions should return an object:\n'</span> <span class="token operator">+</span>
      <span class="token string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// proxy data on instance</span>
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 获取到data的属性</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>props
  <span class="token keyword">const</span> methods <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>methods
  <span class="token keyword">let</span> i <span class="token operator">=</span> keys<span class="token punctuation">.</span>length
  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历每个属性，进行判断是否和props、methods的属性名是否重合 如果重合则抛出错误</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>methods <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>methods<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Object.prototype.hasOwnProperty.call(obj, key)</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Method "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">" has already been defined as a data property.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
          vm
        <span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>props <span class="token operator">&amp;&amp;</span> <span class="token function">hasOwn</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The data property "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">" is already declared as a prop. </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Use prop default value instead.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Check if a string starts with $ or _ 其实就是检查这个属性是不是自定义属性 和vm实例上的vue属性区分开</span>
      <span class="token comment">// 将data的值代理到vm实例上</span>
      <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">// observe data 响应式处理data</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>自定义的 proxy 方法实现通过 <code>Object.defineProperty</code> 把 <code>target[sourceKey][key]</code> 的读写变成了对 <code>target[key]</code> 的读写。将 data 中的数据挂在到实例上。</p>
<p><code>observe</code> 的功能就是用来监测数据的变化。<code>observe</code> 方法的作用就是给非 VNode 的对象类型数据添加一个 <code>Observer</code>，如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。</p>
<p><code>Observer</code> 的构造函数，接下来会对 <code>value</code> 做判断，对于数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code> 方法。</p>
<p><code>defineReactive</code> 函数最开始初始化 <code>Dep</code> 对象的实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，这样就保证了无论 <code>obj</code> 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 <code>obj</code> 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 <code>Object.defineProperty</code> 去给 <code>obj</code> 的属性 <code>key</code> 添加 getter 和 setter。</p>
<blockquote>
<p>观察者模式</p>
</blockquote>
<h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">生命周期钩子</a></h4><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<blockquote>
<p>生命周期函数就是在初始化及数据更新过程各个阶段执行不同的钩子函数</p>
</blockquote>
<p><img src="/posts/28605/lifecycle.png" alt="lifecycle"></p>
<p>生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<blockquote>
<p>所以不能使用箭头函数来定义一个生命周期方法。箭头函数绑定了父级上下文，this 无法指向预期的组件实例。</p>
</blockquote>
<p>在<code>beforeCreate</code>时，<code>data/prop</code>还没有注入到<code>vm</code>实例中，所以是无法获取到<code>data</code>数据的。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// vue2.6x源码部分 4999-5008</span>
<span class="token comment">// expose real self</span>
vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm
<span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 初始化生命周期</span>
<span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 初始化事件</span>
<span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 初始化渲染函数</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
<span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>
<span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 初始化状态 初始化顺序 props methods data computed watch</span>
<span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所以在<code>created</code>时才能获取到<code>data/prop</code>数据并进行交互。</p>
<h5 id="子组件和父组件的生命周期调用"><a href="#子组件和父组件的生命周期调用" class="headerlink" title="子组件和父组件的生命周期调用"></a>子组件和父组件的生命周期调用</h5><p>子组件的其他生命周期在<code>patch</code>时传入，父组件先进行<code>beforeMount</code>然后进行对子组件的递归处理。所以父子组件<em>创建-挂载</em>的生命周期执行顺序是：<code>parent beforeCreate -&gt; parent created -&gt; parent beforeMount -&gt; son beforeCreate -&gt; son created -&gt; son beforeMount -&gt; son mounted -&gt; parent mounted</code></p>
<p>父组件销毁时，父子组件<em>销毁</em>的生命周期执行顺序时：<code>parent beforeDestroy -&gt; son beforeDestroy -&gt; son destroyed -&gt; parent destroyed</code></p>
<p>所以：</p>
<ul>
<li>在created钩子函数中可以访问到数据</li>
<li>在mounted钩子函数中可以访问到DOM</li>
<li>在destroyed钩子函数中可以做一些定时器销毁工作</li>
</ul>
<h5 id="除了常规的组件生命周期，还有"><a href="#除了常规的组件生命周期，还有" class="headerlink" title="除了常规的组件生命周期，还有"></a>除了常规的组件生命周期，还有</h5><ul>
<li><p>activated：被 keep-alive 缓存的组件激活时调用。该钩子在服务器渲染期间不被调用。</p>
</li>
<li><p>deactivated：被 keep-alive 缓存的组件失活时调用。该钩子在服务器渲染期间不被调用。</p>
</li>
<li><p>errorCaptured：在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
<blockquote>
<p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>
<p><strong>错误传播规则</strong></p>
<ul>
<li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</li>
<li>如果一个组件的 inheritance chain (继承链)或 parent chain (父链)中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li>
<li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code>。</li>
<li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code>。</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="服务端的生命周期"><a href="#服务端的生命周期" class="headerlink" title="服务端的生命周期"></a>服务端的生命周期</h5><p>SSR 服务器渲染的生命周期和web渲染的生命周期不同，部分生命周期在服务器渲染期间不被调用。只会调用 beforeCreated、created 生命周期函数。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Vue.js 的生命周期函数就是在初始化及数据更新过程各个阶段执行不同的钩子函数。</p>
<p>在 created 钩子函数中可以访问到数据，在 mounted 钩子函数中可以访问到 DOM，在 destroyed 钩子函数中可以做一些定时器销毁工作。</p>
<h4 id="虚拟DOM（Virtual-DOM）"><a href="#虚拟DOM（Virtual-DOM）" class="headerlink" title="虚拟DOM（Virtual DOM）"></a>虚拟DOM（Virtual DOM）</h4><p><code>Virtual DOM</code> 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 <code>VNode</code> 这么一个 Class 去描述。</p>
<p>其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。</p>
<p>就可以类似搭积木的方式去拼装页面。</p>
<p>实现业务和功能解耦。降低了页面的维护成本。</p>
<p>组件注册的两种方式：<strong>全局注册</strong>（<code>Vue.component(&#39;app&#39;, App)</code>）和<strong>局部注册</strong>（<code>components: &#123;app: App&#125;</code>）。</p>
<p>全局注册的方式会在<code>Vue</code>原型链上进行扩展，一次引入任意地方使用，而局部注册的方式只是在父组件上添加，只有引入才能使用。全局注册的组件可以在任意地方使用，而局部注册的组件只能在当前组件内使用。</p>
<p>通常组件库中的基础组件会使用全局注册，而业务相关的组件会进行局部注册。</p>
<p>组件引入优化，组件库组件进行按需注册，全部注册也会造成资源的浪费。如使用<a target="_blank" rel="noopener" href="https://antdv.com/docs/vue/getting-started-cn/"><code>Antd</code></a>组件库进行开发。</p>
<h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><p>推荐阅读：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6994959998283907102">15张图，20分钟吃透Diff算法核心原理，我说的！！！</a></p>
<p>patch组件的情况有：</p>
<ul>
<li>首次渲染创建新节点；</li>
<li>仅旧节点存在新节点的不存在表示移除旧节点；</li>
<li>仅新节点存在旧节点不存在表示新增新节点；</li>
<li>挂载真实节点，新旧节点不一致则表示销毁旧节点挂载新节点，新旧节点一致进行内容比对。</li>
</ul>
<p>主要讨论新旧节点一致（且新节点的父节点不为真实节点）的情况。</p>
<p>这里的<strong>一致</strong>表示在key值相等的前提下，tag（tagName）、同为或同不为注释节点、定义了data、同为或同不为input元素的条件都满足或同为异步组件的条件下，才判定为是相同的节点。（data中包含了id、class、style的属性值。）</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sameVnode</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// key值相等是前提 然后再进行比对（tag、注释节点、data、都是Input节点） 或 （异步节点 异步包装函数相同 b节点的异步包装函数error未定义）</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    a<span class="token punctuation">.</span>key <span class="token operator">===</span> b<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
      <span class="token punctuation">(</span>
        a<span class="token punctuation">.</span>tag <span class="token operator">===</span> b<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span>
        a<span class="token punctuation">.</span>isComment <span class="token operator">===</span> b<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span>
        <span class="token function">isDef</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">sameInputType</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>
        <span class="token function">isTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isAsyncPlaceholder<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        a<span class="token punctuation">.</span>asyncFactory <span class="token operator">===</span> b<span class="token punctuation">.</span>asyncFactory <span class="token operator">&amp;&amp;</span>
        <span class="token function">isUndef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>asyncFactory<span class="token punctuation">.</span>error<span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 比较两个input节点是否相同 或都不是input节点</span>
<span class="token keyword">function</span> <span class="token function">sameInputType</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>tag <span class="token operator">!==</span> <span class="token string">'input'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token keyword">let</span> i
  <span class="token keyword">const</span> typeA <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span>type
  <span class="token keyword">const</span> typeB <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span>type
  <span class="token keyword">return</span> typeA <span class="token operator">===</span> typeB <span class="token operator">||</span> <span class="token function">isTextInputType</span><span class="token punctuation">(</span>typeA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isTextInputType</span><span class="token punctuation">(</span>typeB<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>进行新旧节点比对（patchVnode）</strong>：</p>
<ul>
<li>如果旧节点等于新节点则直接退出比对。</li>
<li>如果是非异步组件，判断新节点的 <code>prepatch</code> 方法是否存在，存在则执行<code>prepatch(oldVnode, vnode)</code>方法。</li>
<li>如果新节点定义了data且为可挂载节点（有真实节点实例），循环执行 <code>update hook</code> 。</li>
<li>判断是否为文本节点（文本节点已经为组件的最内层的节点了）：<ul>
<li>如果新节点不是文本节点，则进一步判断新旧节点是否都存在子节点。<ul>
<li>如果都存在子节点且不相等就更新子节点（updateChildren）。</li>
<li>如果仅新节点存在子节点则进一步判断旧节点是否为文本节点是就置空，添加新节点。</li>
<li>如果仅旧节点存在子节点则删除旧节点的子节点。</li>
<li>如果都不存在子节点，且旧节点为文本节点，则置空旧节点的文本。</li>
</ul>
</li>
<li>如果新旧节点都是文本节点且值不相等，则直接替换旧节点的文本节点。</li>
</ul>
</li>
<li>如果新节点的<code>postpatch</code>方法存在，则执行<code>postpatch(oldVnode, vnode)</code>方法。</li>
</ul>
<p><strong>子节点比对更新（updateChildren），采用头尾指针的方式进行，先设置新旧子节点的头尾index值、node值，循环遍历新旧节点的子节点差异，直到旧节点的子节点（oldCh）头尾指针交叉或新节点的子节点（newCh）头尾指针交叉为止</strong>：</p>
<ul>
<li><p>oldCh 头指针指向的node节点无效，oldCh继续向后查找<code>++oldStartIdx</code>。</p>
</li>
<li><p>oldCh 尾指针指向的node节点无效，oldCh继续向前查找<code>--oldEndIdx</code>。</p>
</li>
<li><p>oldCh 和 newCh 头指针指向的node节点一致，进行 <code>patchVnode</code> 递归，比对后出栈，oldCh 和 newCh 都继续向后查找。</p>
</li>
<li><p>oldCh 和 newCh 尾指针指向的node节点一致，进行 <code>patchVnode</code> 递归，比对后出栈，oldCh 和 newCh 都继续向前查找。</p>
</li>
<li><p>oldCh 头指针和 newCh 尾指针指向的node节点一致，进行 <code>patchVnode</code> 递归，比对后出栈，如果节点可移动（transition-group组件不可移动），则将比对更新后的 oldCh 头指针节点元素插入到当前oldCh尾指针的后面，oldCh 向后查找，newCh 向前查找。</p>
</li>
<li><p>oldCh 尾指针和 newCh 头指针指向的node节点一致，进行 <code>patchVnode</code> 递归，比对后出栈，如果节点可移动，则将比对更新后的 oldCh 尾指针节点元素插入到当前 oldCh 头指针的前面，oldCh 向前查找，newCh 向后查找。</p>
</li>
<li><p>如果oldCh 和 newCh 当前头尾指针指向的节点都没有关系，即完全没有一致的情况。先遍历获取 oldCh 的 key 值并以<code>key: index</code>键值对的方式存到对象<code>oldKeyToIdx</code>中。如果当前newCh的头指针节点有key值，则在<code>oldKeyToIdx</code>中查找，否则就在oldCh中进行遍历比对如果找到相等的node则返回所在oldCh中的索引，找不到则默认返回undefined。</p>
<ul>
<li>如果在oldCh中没有找到和newCh头指针一致的节点，就克隆newCh头指针的节点并插入到 oldCh 的头指针前。</li>
<li>如果在oldCh中找到了key值相同的节点：<ul>
<li>如果两个节点一致，则进行 <code>patchVnode</code> 递归，比对后出栈，如果当前节点可以可移动，则将更新后的 oldCh 子节点元素插入到 oldCh 头指针前，并置空 oldCh 中index对应的节点，避免重复处理。</li>
<li>如果两个节点不一致，即key值相同，但其实不同的节点，那就作为新的节点对待，克隆newCh头指针的节点并插入到 oldCh 的头指针前。</li>
</ul>
</li>
</ul>
<p>然后 newCh 向后查找。</p>
</li>
<li><p>循环遍历结束后。判断交叉情况：</p>
<ul>
<li>如果 oldCh 的头尾指针交叉，则表示 newCh 中有部分节点没有访问到，确定 newCh 中没有访问到的部分边界，如果 newCh 尾指针后一个节点为未定义，则表明 newCh 头指针及以后的节点都没有被访问到，否则未访问范围为当前 newCh 头指针到尾指针。</li>
<li>如果 newCh 的头尾指针交叉，则表示 oldCh 中有部分节点没有访问到，则移除这部分节点。</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用双指针的方式进行比较，以及克隆节点的方式，能够有效的提升性能。</p>
</blockquote>
<p>可以从diff算法流程中得出，如果随意定义组件的key值则会造成不必要的步骤。diff算法对重排子组件的性能有明显的提升，使用了旧的节点元素进行拼接。</p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><h5 id="codegen"><a href="#codegen" class="headerlink" title="codegen"></a>codegen</h5><p>codegen 的目标是把 AST 树转换成代码字符串。</p>
<p>整个 codegen 过程就是深度遍历 AST 树根据不同条件生成不同代码的过程。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>v-if 和 v-for 不能同时使用，v-for 的优先级要比 v-if 高，但是如果需要一起使用时，使用 template 组件进行v-if 判断后再进行 v-for 循环渲染。v-for 循环渲染避免每个元素进行 v-if 判断。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#v-pre"><code>v-pre</code></a>：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#v-cloak"><code>v-cloak</code></a>：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] &#123; display: none &#125;</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。<strong>用于优化显示</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#v-once"><code>v-once</code></a>：只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
<h4 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h4><h5 id="事件穿透解决方案："><a href="#事件穿透解决方案：" class="headerlink" title="事件穿透解决方案："></a>事件穿透解决方案：</h5><p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86347430">https://zhuanlan.zhihu.com/p/86347430</a></p>
<p>vue框架内置指令v-on:click有300ms的延迟响应，这是为了判断区分单击和双击。vue为移动端提供了触摸方法touchstart、touchmove、touchend，但却没有提供tap指令，因此需要自己手动定义v-tap去消除300ms延迟，提升移动端用户体验。</p>
<h5 id="Event事件"><a href="#Event事件" class="headerlink" title="Event事件"></a>Event事件</h5><p>event 在编译阶段生成相关的data，对于 DOM 事件在 patch 过程中的创建阶段和更新阶段执行 updateDOMListeners 生成 DOM 事件；对于自定义事件，会在组件初始化阶段通过 initEvents 创建。</p>
<p>原生 DOM 事件和自定义事件主要的区别在于添加和删除事件的方式不一样，并且自定义事件的派发是往当前实例上（子组件实例）派发，但是可以利用在父组件环境定义回调函数来实现父子组件的通讯。</p>
<h4 id="双向数据绑定-v-model"><a href="#双向数据绑定-v-model" class="headerlink" title="双向数据绑定 v-model"></a>双向数据绑定 v-model</h4><p>在<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code> 表单元素上创建双向数据绑定，会根据控件类型自动选取正确的方法来更新元素。负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<p>v-model 会忽略所有表单元素的 value、checked、selected属性的初始值，而总是将 Vue 实例的数据作为数据来源。</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件</li>
<li>select 字段将 value 属性作为 prop 并将 change 作为事件</li>
</ul>
<h5 id="修饰符："><a href="#修饰符：" class="headerlink" title="修饰符："></a>修饰符：</h5><p>.lazy：在 change 事件之后进行同步。默认状态为在 input 事件出发后进行数据同步。</p>
<p>.number：自动将用户输入值转为数值类型。如果值无法被 parseFloat() 解析，则返回原始值。</p>
<p>.trim：自动过滤用户输入的首尾空白字符。</p>
<h5 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h5><ul>
<li><p>表单使用</p>
<ul>
<li>input 组件<ul>
<li>v-model 的功能与<code>&lt;input :value=&quot;message&quot; @input=&quot;message=$event.target.value&quot;&gt;</code>大致相同。</li>
<li>v-model 和 v-bind:value 的方式区别，v-model内部使用了 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/compositionstart_event">compositionstart</a> 事件监听，在用户使用输入法进行拼写的时候，拼写完成才触发 input 事件，减少了事件触发频率。</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">组件使用</a></p>
<p>v-model 在子组件上使用会默认生成 prop 中的 value 属性和 input 事件。将父组件的值传入子组件 prop 的 value 中，使用 input 的函数进行派发传值，父子通讯。</p>
<p>也可以在子组件中定义 model 对象，指定 父组件的 v-model 对应子组件中自定义的 prop 和methods </p>
</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>v-model 的本质就是语法糖，但是运行时也做了一些优化。</li>
<li>v-model 即可以支持原生表单元素，也可以支持组件。在组件的实现中，可以配置子组件接收的 prop 名称，以及派发的事件名称。</li>
</ul>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝。<strong>避免组件复用时数据相互影响</strong>。使用闭包的原理封装出独立的环境。</p>
<p>数据流向：单向流动。父组件流向子组件。子组件不能修改prop值。</p>
<blockquote>
<p>防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。</p>
<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。<strong>如果子组件复制prop的引用类型最好要进行深拷贝</strong>。</p>
</blockquote>
<p>子组件中的prop设置校验规则后，会在创建子组件实例之前校验prop。</p>
<h5 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-registration.html">组件注册</a></h5><p>全局组件注册要在初始化Vue实例之前进行。使用<code>Vue.component(...)</code>方式进行创建。</p>
<h5 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html">异步组件</a></h5><p>异步组件使用工厂函数进行异步导入组件，将应用分割成小一些的代码块。</p>
<blockquote>
<p>会进行两次及以上的渲染，因为 Vue 通常是数据驱动视图重新渲染，但是在整个异步组件加载过程中是没有数据发生变化的，所以要渲染异步组件需要强制刷新。</p>
</blockquote>
<h6 id="webpack-code-splitting"><a href="#webpack-code-splitting" class="headerlink" title="webpack + code splitting"></a>webpack + code splitting</h6><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'async-webpack-example'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 这个特殊的 `require` 语法将会告诉 webpack</span>
  <span class="token comment">// 自动将你的构建代码切割成多个包，这些包</span>
  <span class="token comment">// 会通过 Ajax 请求加载</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./my-async-component'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="import异步导入"><a href="#import异步导入" class="headerlink" title="import异步导入"></a>import异步导入</h6><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 全局注册</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>
  <span class="token string">'async-webpack-example'</span><span class="token punctuation">,</span>
  <span class="token comment">// 这个动态导入会返回一个 `Promise` 对象。</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-async-component'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment">// 局部注册</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token comment">// ...</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string-property property">'my-component'</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-async-component'</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="高级异步组件-–-组件加载状态"><a href="#高级异步组件-–-组件加载状态" class="headerlink" title="高级异步组件 – 组件加载状态"></a>高级异步组件 – 组件加载状态</h6><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> LoadingComp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;div>loading&lt;/div>'</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> ErrorComp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;div>error&lt;/div>'</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> <span class="token function-variable function">AsyncComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span>
  <span class="token literal-property property">component</span><span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./MyComponent.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// 异步组件加载时使用的组件</span>
  <span class="token literal-property property">loading</span><span class="token operator">:</span> LoadingComponent<span class="token punctuation">,</span>
  <span class="token comment">// 加载失败时使用的组件</span>
  <span class="token literal-property property">error</span><span class="token operator">:</span> ErrorComponent<span class="token punctuation">,</span>
  <span class="token comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span>
  <span class="token literal-property property">delay</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>
  <span class="token comment">// 如果提供了超时时间且组件加载也超时了，</span>
  <span class="token comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">3000</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="组件间传值"><a href="#组件间传值" class="headerlink" title="组件间传值"></a>组件间传值</h5><h6 id="使用v-bind-prop传值"><a href="#使用v-bind-prop传值" class="headerlink" title="使用v-bind prop传值"></a>使用v-bind prop传值</h6><p>传入单个值。可以传入静态值或动态值。</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 父组件
&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
    &lt;HelloWorld v-bind:authorObj&#x3D;&quot;author&quot; v-bind:author&#x3D;&quot;&#123; name: &#39;Veronica&#39;, company: &#39;Veridian Dynamics&#39; &#125;&quot; &#x2F;&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&#x2F;&#x2F; 子组件
props: &#123;
    author: Object,
	authorObj: Object
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>传入多个值。将所有欲传入子组件的值全部放到一个对象中。</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 父组件
&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
    &lt;HelloWorld v-bind&#x3D;&quot;post&quot; &#x2F;&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;
...
data() &#123;
	return &#123;
		post: &#123;
            msg1: &#39;xxxx&#39;,
            author: &#123; name: &#39;Veronica&#39;, company: &#39;Veridian Dynamics&#39; &#125;
		&#125;
	&#125;
&#125;
...
&#x2F;&#x2F; 子组件
props: [&#39;msg&#39;,&#39;author&#39;],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="省略v-bind-prop传值"><a href="#省略v-bind-prop传值" class="headerlink" title="省略v-bind prop传值"></a>省略v-bind prop传值</h6><p>单个传值。</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 父组件
&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
    &lt;HelloWorld msg&#x3D;&quot;Welcome to Your Vue.js App&quot; :msg1&#x3D;&quot;msg1&quot; :bol&#x3D;&quot;true&quot; :num&#x3D;&quot;123&quot; :arr&#x3D;&quot;[1, 2, 3]&quot; &#x2F;&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&#x2F;&#x2F; 子组件
props: &#123;
    msg: String,
	msg1: String,
	bol: Boolean,
	num: Number,
	arr: Array
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注：只有<code>String</code>类型才能省略<code>:</code> 进行静态传值，其他类型的值会被识别为字符串类型。其他类型使用静态传值时必须使用<code>:</code></p>
<h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p><strong>使用 Object.defineProperty()，将依赖关系定义为 watcher 数组并设置到每个值的 getter 中，当一个数据发生改变会将会触发订阅了当前数据的数据发生改变。</strong></p>
<h5 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h5><p>vue维护的是一个函数队列，先进先出的规则，先声明的函数会先执行，所以如果nextTick在数据更新前声明，则拿到的数据是未更新的数据。同时也要注意数据更新后<strong>同步</strong>拿到DOM中innerHTML是旧数据，只有进行触发了update才能拿到新数据，nextTick就可以使用微任务机制，在宏任务执行完成即更新数据后（update hook &amp; activate hook）执行微任务（nextTick）获取DOM中的数据，此时数据已经是新数据了。</p>
<p><strong>vue的数据更新是异步的</strong>。</p>
<blockquote>
<p>nextTick理解其实就是回调函数，但是由于回调函数层层传递过于复杂，使用微任务机制可以更加清晰明了，不用在意宏任务里面做了什么操作，只需要宏任务执行完成后立马执行微任务。</p>
<p>回调函数本质也是在执行某些操作后立马执行回调函数，但是回调函数会影响到多层函数。</p>
</blockquote>
<h5 id="数据改变无法检测到的情况"><a href="#数据改变无法检测到的情况" class="headerlink" title="数据改变无法检测到的情况"></a>数据改变无法检测到的情况</h5><p>对于引用类型如对象设置新属性（<code>obj.a = &#39;a&#39;</code>）和数组添加元素（<code>arr[1] = 1</code>），无法触发数据的setter，所以要使用Vue.set 接口进行解决，操作数组数据的原生api如<code>shift</code>等其实是底层进行了重写和封装，添加了数据改变的通知，对象的delete操作也是一样。</p>
<h5 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h5><p><strong>computed计算属性是基于它们的响应式依赖进行缓存的</strong>，只在相关响应式依赖发生改变时它们才会重新求值，如果新值和旧值相同也不会触发重新渲染。computed属性定义如果是函数则默认为getter函数，如果需要设置computed的值则将定义声明为对象，对象中的getter和setter函数分别设置到computed属性上。不推荐使用调用方法是因为当重新渲染时会重新执行一遍调用方法，而使用computed属性能够使用缓存值减少重新计算。</p>
<p><strong>watch侦听属性是在一些数据变动时需要做额外的操作时使用</strong>，如当数据发生变化时请求接口。watch实现引用类型的深度监听，需要定义handler函数和deep属性。可以使用数组声明需要回调的一系列函数。使用sync属性能立马响应watch的回调而不用等到nextTick时才进行响应。使用immediate属性则会在监听开始之后被立即调用。</p>
<p>watch监听引用类型（数组和对象，即使定义deep属性也不行），拿不到oldVal，oldVal和newVal是一样的。但是如果对象监听到具体的某个属性，则可以获取到oldVal。</p>
<p>watch侦听属性除了使用数据的方式声明还可以使用实例挂载的方式<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code></a>，实例方法能够做更加复杂的操作。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个 property。</p>
<p><strong>应用场景</strong>：computed计算属性适合在模板渲染中，某个值是依赖了其他的响应式对象甚至是计算属性计算而来；watch侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<h5 id="set使用"><a href="#set使用" class="headerlink" title="$set使用"></a>$set使用</h5><p>$set方法对象的使用：this.$set(this.obj, “key”, “value”)，在对象中新增一个属性，将该属性手动进行响应式处理。</p>
<p>push()、pop()、shift()、unshift()、splice()、sort()、reverse()这些方法会改变被操作的数组，所以会触发数组更改的响应式。</p>
<h4 id="插槽-v-slot"><a href="#插槽-v-slot" class="headerlink" title="插槽 v-slot"></a>插槽 v-slot</h4><p>如果子组件的 <code>template</code> 中<strong>没有</strong>包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p>
<p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p>
<blockquote>
<p>普通插槽在父组件中定义子组件中 slot 的内容是在父组件的作用域中编译的，父组件的内容无法访问到子组件中的内容。</p>
<p>如果想要访问到子组件的作用域，则需要使用作用域插槽。</p>
</blockquote>
<p>可以使用 <strong><code>#</code></strong> 进行缩写。</p>
<p>如果父组件没有定义 slot 内容，则子组件的 slot 如果定义了默认内容则会显示默认内容。</p>
<h5 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h5><p>父组件</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
    &lt;HelloWorld&gt;
      &lt;template v-slot&gt;slot&lt;&#x2F;template&gt;
    &lt;&#x2F;HelloWorld&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;

export default &#123;
  name: &#39;App&#39;,
  components: &#123;
    HelloWorld
  &#125;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>子组件</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div class&#x3D;&quot;hello&quot;&gt;
    &lt;slot&gt;默认内容&lt;&#x2F;slot&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在父组件编译和渲染阶段生成vnodes，所以数据的作用域是父组件实例，子组件渲染的时候直接拿到这些渲染好的vnodes。</p>
<h5 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h5><p>父组件</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
    &lt;HelloWorld&gt;
      &lt;template v-slot:header&gt;Header&lt;&#x2F;template&gt;
      &lt;template v-slot:footer&gt;Footer&lt;&#x2F;template&gt;
    &lt;&#x2F;HelloWorld&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;

export default &#123;
  name: &#39;App&#39;,
  components: &#123;
    HelloWorld
  &#125;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>子组件</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div class&#x3D;&quot;hello&quot;&gt;
    &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt;
    &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>插槽需要访问子组件中才有的数据。子组件中的 slot 上绑定父组件需要使用的值，即插槽prop。在父组件就可以拿到插槽 prop 合并成的对象，父组件将这个对象自定义命名，然后就可以在插槽中使用子组件中的值了。</p>
<p>父组件</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div id&#x3D;&quot;app&quot;&gt;
    &lt;HelloWorld&gt;
      &lt;template #header&#x3D;&quot;slotProps&quot;&gt; 
          app: &#123;&#123; slotProps.testObj.test &#125;&#125;\&#123;&#123; slotProps.test &#125;&#125;
	  &lt;&#x2F;template&gt;
    &lt;&#x2F;HelloWorld&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;

export default &#123;
  name: &#39;App&#39;,
  components: &#123;
    HelloWorld
  &#125;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>子组件</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;
  &lt;div class&#x3D;&quot;hello&quot;&gt;
    &lt;slot name&#x3D;&quot;header&quot; :testObj&#x3D;&quot;testObj&quot; :test&#x3D;&quot;test&quot;&gt;
      HelloWorld: &#123;&#123; test &#125;&#125;
    &lt;&#x2F;slot&gt;
  &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;HelloWorld&#39;,
  data() &#123;
    return &#123;
      test: &#39;xxx&#39;,
      testObj: &#123;
        test: &#39;ss&#39;
      &#125;,
    &#125;
  &#125;,
&#125;
&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>父组件在编译和渲染阶段并不会直接生成 vnodes ，而是在父节点 vnode 的 data 中保留一个scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，只有在渲染子组件阶段才会执行这个渲染函数生成 vnodes ，所以父组件中的 slot 可以访问到子组件的插槽prop。</p>
<h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">keep-alive</a></h4><p>抽象组件，保存组件状态，防止重复渲染导致性能问题。<code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p>
<blockquote>
<p>keep-alive 要求被切换到的组件都要有自己的名字，不论时通过组件的name选项还是局部/全局注册。</p>
<p>不会在函数式组件中正常工作，因为函数式组件没有缓存实例。</p>
<p>抽象组件，自身不会渲染一个DOM元素，也不会出现在组件的父组件链中。</p>
</blockquote>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 失活的组件将会被缓存！--&gt;
&lt;keep-alive&gt;
  &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;
&lt;&#x2F;keep-alive&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>当组件在 <code>keep-alive</code> 内被切换，会执行 activated 和 deactivated 生命周期钩子会执行。</p>
<blockquote>
<p>这两个生命周期钩子是 keep-alive 特有的。</p>
<p>组件初始化时，mounted 生命周期钩子执行完后，才执行activated 生命周期钩子。但如果组件已经进行缓存了，则组件再次被激活时不会触发mounted生命周期钩子函数，只会触发activated 生命周期钩子函数。</p>
</blockquote>
<ul>
<li><p><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</p>
<blockquote>
<p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)。匿名组件不能被匹配。</p>
</blockquote>
</li>
<li><p><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</p>
</li>
<li><p><code>max</code> - 数字。最多可以缓存多少组件实例。</p>
</li>
</ul>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 逗号分隔字符串 --&gt;
&lt;keep-alive include&#x3D;&quot;a,b&quot;&gt;
  &lt;component :is&#x3D;&quot;view&quot;&gt;&lt;&#x2F;component&gt;
&lt;&#x2F;keep-alive&gt;

&lt;!-- 正则表达式 (使用 &#96;v-bind&#96;) --&gt;
&lt;keep-alive :include&#x3D;&quot;&#x2F;a|b&#x2F;&quot;&gt;
  &lt;component :is&#x3D;&quot;view&quot;&gt;&lt;&#x2F;component&gt;
&lt;&#x2F;keep-alive&gt;

&lt;!-- 数组 (使用 &#96;v-bind&#96;) --&gt;
&lt;keep-alive :include&#x3D;&quot;[&#39;a&#39;, &#39;b&#39;]&quot;&gt;
  &lt;component :is&#x3D;&quot;view&quot;&gt;&lt;&#x2F;component&gt;
&lt;&#x2F;keep-alive&gt;

&lt;!-- 使用max --&gt;
&lt;keep-alive :max&#x3D;&quot;10&quot;&gt;
  &lt;component :is&#x3D;&quot;view&quot;&gt;&lt;&#x2F;component&gt;
&lt;&#x2F;keep-alive&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在首次渲染时会直接执行 activated 钩子函数，在再次激活组件时会在 nextTick 后先执行 activated 钩子函数然后执行 updated 钩子函数。失活组件的时候会执行 deactivated 钩子函数。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>keep-alive 组件时一个内置抽象组件，它的实现通过自定义 render 函数并且利用了插槽。</p>
<p>keep-alive 组件的渲染分为首次渲染和缓存渲染。首次渲染时会将实例缓存起来，当命中缓存，则不会再执行 created 和 mounted 钩子函数，而会执行 activated 钩子函数。销毁时也不会执行 destroyed 钩子函数，而会执行 deactivated 钩子函数。</p>
<p>keep-alive 的 max 属性采用的最近最少使用算法（LRU）进行处理，避免缓存内容过多占用内容。</p>
<h4 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h4><h5 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h5><p>内置<strong>抽象</strong>组件。</p>
<p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p>
<ol>
<li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li>
<li>如果过渡组件提供了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90">JavaScript 钩子函数</a>，这些钩子函数将在恰当的时机被调用。</li>
<li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 <code>nextTick</code> 概念不同)</li>
</ol>
<p>过渡的css类名：</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>：定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<blockquote>
<p>以上的过渡类名为默认类名，可以自定义声明 name ，会将自定义name 替换掉 v-，如 name 为 fade 则类名为 fade-enter。</p>
<p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线。</p>
</blockquote>
<p><img src="/posts/28605/transition.jpg" alt="transition"></p>
<h5 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h5><ul>
<li><p>会渲染成真实的元素。默认为一个 <code>&lt;span&gt;</code>。你也可以通过 <code>tag</code> attribute 更换为其他元素。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E6%A8%A1%E5%BC%8F">过渡模式</a>不可用，因为我们不再相互切换特有的元素。</p>
</li>
<li><p>内部元素<strong>总是需要</strong>提供唯一的 <code>key</code> attribute 值。</p>
</li>
<li><p>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。</p>
</li>
<li><p>transition-group组件属性是在transition组件上进行扩展的，所以transition组件的属性transition-group组件也可以使用。</p>
</li>
</ul>
<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p><code>transition-group</code> 组件时为了做列表的过渡，它会渲染成真实的元素。</p>
<p>当我们去修改列表的数据的时候，如果是添加或者删除数据，则会触发相应元素本身的过渡动画，这点和 <code>&lt;transition&gt;</code>组件实现效果一样，除此之外 <code>&lt;transition-group&gt;</code>还实现了 move 的过渡效果，让我们的列表过渡动画更加丰富。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h4><p>v-show 会在页面首次渲染的时候进行渲染加载，修改条件后不会重新渲染。</p>
<p>v-if 不会在页面初始化的时候渲染，但是条件为真值时会进行渲染加载，条件为假值时会进行销毁。</p>
<p>组件显示条件修改不是很频繁则使用 v-if，反之使用 v-show。</p>
<h4 id="为何-v-for-中要用key"><a href="#为何-v-for-中要用key" class="headerlink" title="为何 v-for 中要用key"></a>为何 v-for 中要用key</h4><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#key">key</a>：<code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<p>有相同父元素的子元素必须有<strong>独特的 key</strong>。重复的 key 会造成渲染错误。</p>
<p>更新key值可以完整地触发组件的生命周期钩子，触发过渡。</p>
<h4 id="描述Vue组件生命周期（有父子组件的情况）"><a href="#描述Vue组件生命周期（有父子组件的情况）" class="headerlink" title="描述Vue组件生命周期（有父子组件的情况）"></a>描述Vue组件生命周期（有父子组件的情况）</h4><p>更详细的参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6904536680183791623">https://juejin.cn/post/6904536680183791623</a></p>
<h4 id="父子组件通讯"><a href="#父子组件通讯" class="headerlink" title="父子组件通讯"></a>父子组件通讯</h4><p>子组件获取父组件数据：</p>
<ul>
<li>父组件 props 传值</li>
<li>子组件访问父组件实例：this.$parent</li>
<li>子组件访问根组件实例：this.$root</li>
<li>分发监听 this.$root.$emit(‘eventName’, data)</li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#provide-inject">inject</a> - 在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的 property</li>
<li>vuex</li>
</ul>
<p>父组件获取子组件传值：</p>
<ul>
<li>子组件 this.$emit(‘eventName’, data) </li>
<li>建立监听 this.$root.$on(‘eventName’, callback)</li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#provide-inject">provide</a> - 选项允许我们指定我们想要<strong>提供</strong>给后代组件的数据/方法</li>
<li>this.$refs.elm</li>
<li>vuex</li>
<li>v-model</li>
</ul>
<h4 id="兄弟组件通讯"><a href="#兄弟组件通讯" class="headerlink" title="兄弟组件通讯"></a>兄弟组件通讯</h4><ul>
<li>父组件搭桥，兄弟组件通过 $emit 方式将值传递给父组件，父组件再传值给兄弟组件</li>
<li>vuex </li>
<li>eventBus</li>
</ul>
<h4 id="描述组件渲染和更新的过程"><a href="#描述组件渲染和更新的过程" class="headerlink" title="描述组件渲染和更新的过程"></a>描述组件渲染和更新的过程</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42072086/article/details/108006061">https://blog.csdn.net/qq_42072086/article/details/108006061</a></p>
<p>渲染组件时，会通过 Vue.extend 方法构建子组件的构造函数，初始化组件的时候会进行实例化。终手动调用 $mount() 进行组件挂载渲染。更新组件时会进行 patchVnode 流程。核心就是diﬀ算法。</p>
<p><img src="/posts/28605/%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0.png" alt="组件渲染更新"></p>
<h4 id="双向数据绑定v-model的实现原理"><a href="#双向数据绑定v-model的实现原理" class="headerlink" title="双向数据绑定v-model的实现原理"></a>双向数据绑定v-model的实现原理</h4><h4 id="为什么Vue组件中的data要使用function的方式"><a href="#为什么Vue组件中的data要使用function的方式" class="headerlink" title="为什么Vue组件中的data要使用function的方式"></a>为什么Vue组件中的data要使用function的方式</h4><p>参考官网：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><code>data</code> 必须是一个函数</a></p>
<p><strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝。 </p>
<p>对于组件复用而言，每个组件的data要相互独立，互不影响。如果data是一个对象，多个组件引用的则是同一个内存地址上的对象数据。使用函数返回一个对象，则形成了一个闭包，创建了独立的对象引用地址。</p>
<h4 id="为什么要使用计算属性"><a href="#为什么要使用计算属性" class="headerlink" title="为什么要使用计算属性"></a>为什么要使用计算属性</h4><p>避免在模板中放入太多的逻辑，导致模板过重且难以维护。</p>
<p>计算属性是基于它们的响应式依赖进行缓存的,只在相关响应式依赖发生改变时它们才会重新求值。</p>
<h4 id="watch监听属性"><a href="#watch监听属性" class="headerlink" title="watch监听属性"></a>watch监听属性</h4><p>watch监听属性不可以使用箭头函数进行定义，因为箭头函数中的this指向的是定义时的this，而不是执行时的this，所以不会指向Vue实例的上下文，而是 <code>undefined</code>。</p>
<p>watch定义的函数中 this 指向为 当前组件实例 vm。</p>
<h4 id="组件的选项和混入的选项是怎么合并的"><a href="#组件的选项和混入的选项是怎么合并的" class="headerlink" title="组件的选项和混入的选项是怎么合并的"></a>组件的选项和混入的选项是怎么合并的</h4><ul>
<li>数据对象（data选项），在内部进行递归合并，并在发生冲突时以<strong>组件数据</strong>优先；</li>
<li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用；</li>
<li>watch对象合并时，相同的key合成一个对象，且混入监听在组件监听之前调用；</li>
<li>值为对象的选项，如filters选项、computed选项、methods选项、components选项、directives选项，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>
</ul>
<h4 id="强制刷新组件的方法"><a href="#强制刷新组件的方法" class="headerlink" title="强制刷新组件的方法"></a>强制刷新组件的方法</h4><ul>
<li>vm.$forceUpdate()。</li>
<li>组件上定义key值，修改key值。</li>
</ul>
<h4 id="销毁组件"><a href="#销毁组件" class="headerlink" title="销毁组件"></a>销毁组件</h4><ul>
<li>没有 keep-alive 时的路由切换</li>
<li>v-if=”false”</li>
<li>执行vm.$destroy()</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>vue2.x</code>版本使用 <code>Flow.js</code> 进行数据类型检测。</p>
<h4 id="router"><a href="#router" class="headerlink" title="router"></a>router</h4><p>注意点：不同的页面使用的是同一个component，默认情况下当这两个页面切换时并不会触发vue的created或者mounted钩子，可以通过watch $route的变化来做处理，另一种方法在 router-view 上加上一个唯一的key，来保证路由切换时都会重新渲染触发钩子了。</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;router-view :key&#x3D;&quot;key&quot;&gt;&lt;&#x2F;router-view&gt;

computed: &#123;
    key() &#123;
        return this.$route.name !&#x3D;&#x3D; undefined? this.$route.name + +new Date(): this.$route + +new Date()
    &#125;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="vue实例方法"><a href="#vue实例方法" class="headerlink" title="vue实例方法"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6">vue实例方法</a></h4><p><code>vm.$on(event, callback)</code>、<code>vm.$once(event, callback)</code>、<code>vm.$off([event, callback])</code> <code>vm.$emit(eventName, [...args])</code>四个方法，vue自带了订阅-发布模式。</p>
<h3 id="自检"><a href="#自检" class="headerlink" title="自检"></a>自检</h3><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903874709766152">Vue初级前端工程师面试必备 - 掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903934306287629">Vue初级面试题汇总 - 掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903934314676231">Vue中级面试题汇总 - 掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903913498345479">Vue高级面试题汇总 - 掘金</a></p>
<p>（以上面试题，可看题目，部分解答有问题，自行判断）</p>
<p>推荐：vue面试题 - <a target="_blank" rel="noopener" href="https://juejin.cn/post/6947847527253311496">https://juejin.cn/post/6947847527253311496</a></p>
<h4 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h4><p>vue源码分析 - <a target="_blank" rel="noopener" href="https://juejin.cn/post/6886266739378618382#heading-9">https://juejin.cn/post/6886266739378618382#heading-9</a></p>
<p><a target="_blank" rel="noopener" href="https://godbasin.github.io/vue-ebook/">深入理解 vue.js 实战</a>：（源码）<a target="_blank" rel="noopener" href="https://github.com/godbasin/vue-ebook">https://github.com/godbasin/vue-ebook</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/cyyspring/vuejs/936826">Vue&amp;&amp;TypeSprict–基础总结</a></p>
<p><a target="_blank" rel="noopener" href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">vue.js 技术揭秘</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Wang Wei
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://datura35422.github.io/posts/28605/" title="vue系列-vue入门">https://datura35422.github.io/posts/28605/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
              <a href="/tags/vue/" rel="tag"># vue</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/37130/" rel="prev" title="基础系列-ECMAScript规范">
                  <i class="fa fa-chevron-left"></i> 基础系列-ECMAScript规范
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/29902/" rel="next" title="vue的UI框架整理">
                  vue的UI框架整理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Wei</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">707k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">19:38</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>


<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
var options = {
  bottom: '64px', // default: '32px'
  right: '32px', // default: '32px'
  left: 'unset', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":120,"height":200,"position":"right","hOffset":0,"vOffset":60},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
